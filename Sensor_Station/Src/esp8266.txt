#ifndef _ESP8266_H
#define _ESP8266_H

#include "stm32f3xx_hal.h"
#include "string.h"

#define ESP8266_SSID       "ESP8266"
#define ESP8266_PASSWORD   "password"
#define ESP8266_PORT       80

#define ESP8266_BAUDRATE   500000 

void ESP8266_Init(void);
void ESP8266_Send(uint8_t *buffer, uint16_t length);
void ESP8266_Diag(void);


#endif

#include "esp8266.h"

extern UART_HandleTypeDef huart1;
extern UART_HandleTypeDef huart2;
#define WIFI_UART &huart2
#define CRUIZ_UART &huart1

uint8_t rx_byte_wf = 0;
uint8_t rx_byte_cz = 0;
volatile uint8_t ipd_counter = 0;
volatile uint8_t busy_counter = 0;
volatile uint8_t tx_ready_counter = 0;
volatile uint8_t tx_send_ok_counter = 0;
volatile uint8_t tx_busy_flag = 0;
volatile uint8_t tx_ready_flag = 0;

volatile uint8_t tx_send_ok_flag = 0;

volatile uint8_t tx_send_fail_counter = 0;
volatile uint8_t tx_send_fail_flag = 0;

volatile uint8_t cz_header_counter = 0;
volatile uint8_t cz_header_captured = 0;
volatile uint8_t cz_message_counter = 0;
volatile uint8_t cz_previous_byte = 0;


uint8_t cruiz_buffer[12];
uint8_t send_request = 0;

extern uint16_t cruiz_rate;
extern uint16_t cruiz_angle;

extern uint8_t wifi_command;


void HAL_UART_ErrorCallback( UART_HandleTypeDef *huart ) {
	HAL_GPIO_WritePin( GPIOE, GPIO_PIN_8, GPIO_PIN_SET );
	__HAL_UART_FLUSH_DRREGISTER(huart); 
	if ( huart == CRUIZ_UART )
		HAL_UART_Receive_IT(huart,&rx_byte_cz,1); // try to receive again
};




void HAL_UART_RxCpltCallback( UART_HandleTypeDef *huart ) {
	
	uint8_t command = 0;

// WIFI interrupt

	if ( huart == WIFI_UART ) {
		
		HAL_GPIO_WritePin( GPIOE, GPIO_PIN_10, GPIO_PIN_SET );
		
		// Send ready
		if (rx_byte_wf == '>')
			tx_ready_flag = 1;
		
		// Parse input byte
		switch (ipd_counter) {
			case 0:	if (rx_byte_wf == '+') ipd_counter++; else ipd_counter = 0; break;
			case 1:	if (rx_byte_wf == 'I') ipd_counter++; else ipd_counter = 0; break;
			case 2:	if (rx_byte_wf == 'P') ipd_counter++; else ipd_counter = 0; break;
			case 3:	if (rx_byte_wf == 'D') ipd_counter++; else ipd_counter = 0; break;
			case 4:	if (rx_byte_wf == ',') ipd_counter++; else ipd_counter = 0; break;
			case 5:	ipd_counter++;  break;
			case 6:	if (rx_byte_wf == ',') ipd_counter++; else ipd_counter = 0; break;
			case 7:	ipd_counter++;  break;
			case 8:	if (rx_byte_wf == ':') ipd_counter++; else ipd_counter = 0; break;
			case 9:	command = rx_byte_wf; ipd_counter = 0; break;
		}
		
		// Parse busy state
		switch (busy_counter) {
			case 0:	if (rx_byte_wf == 'b') busy_counter++; else busy_counter = 0; break;
			case 1:	if (rx_byte_wf == 'u') busy_counter++; else busy_counter = 0; break;
			case 2:	if (rx_byte_wf == 's') busy_counter++; else busy_counter = 0; break;
			case 3:	if (rx_byte_wf == 'y') busy_counter++; else busy_counter = 0; break;
			case 4:	tx_busy_flag = 1; busy_counter = 0; break;
		}

		// Parse OK
		switch (tx_send_ok_counter) {
			case 0:	if (rx_byte_wf == 'O' ) tx_send_ok_counter++; else tx_send_ok_counter = 0; break;
			case 1:	if (rx_byte_wf == 'K' ) tx_send_ok_counter++; else tx_send_ok_counter = 0; break;
			case 2:	if (rx_byte_wf == '\r') tx_send_ok_counter++; else tx_send_ok_counter = 0; break;
			case 3:	if (rx_byte_wf == '\n') tx_send_ok_flag = 1; tx_send_ok_counter = 0; break;
		}

		// Parse FAIL
		switch (tx_send_fail_counter) {
			case 0:	if (rx_byte_wf == 'F' ) tx_send_fail_counter++; else tx_send_fail_counter = 0; break;
			case 1:	if (rx_byte_wf == 'A' ) tx_send_fail_counter++; else tx_send_fail_counter = 0; break;
			case 2:	if (rx_byte_wf == 'I' ) tx_send_fail_counter++; else tx_send_fail_counter = 0; break;
			case 3:	if (rx_byte_wf == 'L' ) tx_send_fail_flag = 1; tx_send_fail_counter = 0; break;
		}
		
		// Process received command: Toggle LED
		if (command) {
			wifi_command = command;
		}
		HAL_UART_Receive_IT(huart,&rx_byte_wf,1);
		HAL_GPIO_WritePin( GPIOE, GPIO_PIN_10, GPIO_PIN_RESET );
		return;
	}
	
};




	
void ESP8266_Init(void) {
	
	char str[100];
	HAL_Delay(100);		
	
	// Change baudrate
	sprintf(str, "AT+CIOBAUD=%d\r\n",ESP8266_BAUDRATE);
	HAL_UART_Transmit(WIFI_UART,(uint8_t*)str,strlen(str), HAL_MAX_DELAY );	
	*WIFI_UART.Init.BaudRate = ESP8266_BAUDRATE;
  HAL_UART_Init(WIFI_UART);
	HAL_UART_Receive_IT(WIFI_UART,&rx_byte_wf,1);	
	HAL_Delay(100);	
	
	// Multiple connections
	sprintf(str,"AT+CIPMUX=1\r\n");
	HAL_UART_Transmit(WIFI_UART,(uint8_t*)str,strlen(str), HAL_MAX_DELAY );
	HAL_Delay(100);
	
	// Start UDP
	sprintf(str,"AT+CIPSTART=1,\"UDP\",\"192.168.4.1\",%d,%d,2\r\n",ESP8266_PORT,ESP8266_PORT);
	HAL_UART_Transmit(WIFI_UART,(uint8_t*)str,strlen(str), HAL_MAX_DELAY );

	for (int i = 0; i < 8; i++) {
		HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_14);
		HAL_Delay(100);
	}
	
	
};


void ESP8266_Send(uint8_t *buffer, uint16_t length) {

	char str[100];
	
	tx_ready_flag = 0;
	tx_busy_flag = 0;
	sprintf(str, "AT+CIPSEND=1,%d\r\n",length);
	
	do { // refactoring is desirable
		HAL_UART_Transmit_IT( WIFI_UART, (uint8_t*)str, strlen(str) );	
		while ((!tx_ready_flag) && (!tx_busy_flag)) {};
	} while (tx_busy_flag);
	
	tx_send_ok_flag = 0;
	tx_send_fail_flag = 0;
	HAL_UART_Transmit_IT(WIFI_UART,buffer,length );
	
	while (( !tx_send_ok_flag ) && (!tx_send_fail_flag))  {};
	HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_15);	

};

